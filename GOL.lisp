;;Notes
;;Rule is B3/S23
;;Live cells are 1's dead are 0's
;;Example for algorithim:
;;Center Cell Key = (x . y) Surrounding Keys: T = (x . y+1) TR = (x+1 . y+1) R = (x+1 . y) BR = (x+1 . y-1) B = (x . y-1) BL = (x-1 . y-1) L = (x-1 . y) TL = (x-1 . y+1)
;;Sum up the return values from "get-hash" using each surrounding key
;;According to rule, if result is 2, do nothing, if 3, set center cell to 1, else, set center cell to 0
;;Draw board and repeat.

;;TODO:
;;Add presets such as "gosper glider gun" A.K.A. "init-ggg"
;;Find a way to center the patterns...
;;Add patterns for highlife
;;Better integrate highlife
;;Clean up this mess

(ql:quickload 'lispbuilder-sdl)
(ql:quickload 'lispbuilder-sdl-gfx)

(defparameter *cells* (make-hash-table :test #'equal))
(defparameter *cells-temp* (make-hash-table :test #'equal))
(defparameter *width* 100)
(defparameter *height* 100)
(defparameter *pixsize* 5)

(defun init-pdh ()
  (setf (gethash (cons 45 25) *cells*) 1)
  (setf (gethash (cons 46 25) *cells*) 1)
  (setf (gethash (cons 47 25) *cells*) 1)
  (setf (gethash (cons 48 25) *cells*) 1)
  (setf (gethash (cons 49 25) *cells*) 1)
  (setf (gethash (cons 50 25) *cells*) 1)
  (setf (gethash (cons 51 25) *cells*) 1)
  (setf (gethash (cons 52 25) *cells*) 1)
  (setf (gethash (cons 53 25) *cells*) 1)
  (setf (gethash (cons 54 25) *cells*) 1))

(defun init-pulsar ()
  (setf (gethash (cons 50 25) *cells*) 1)
  (setf (gethash (cons 50 26) *cells*) 1)
  (setf (gethash (cons 50 27) *cells*) 1)
  (setf (gethash (cons 51 24) *cells*) 1)
  (setf (gethash (cons 51 25) *cells*) 1)
  (setf (gethash (cons 51 27) *cells*) 1)
  (setf (gethash (cons 51 28) *cells*) 1)
  (setf (gethash (cons 52 25) *cells*) 1)
  (setf (gethash (cons 52 26) *cells*) 1)
  (setf (gethash (cons 52 27) *cells*) 1))

(defun init-blse ()
  (setf (gethash (cons 50 25) *cells*) 1)
  (setf (gethash (cons 52 25) *cells*) 1)
  (setf (gethash (cons 52 24) *cells*) 1)
  (setf (gethash (cons 54 23) *cells*) 1)
  (setf (gethash (cons 54 22) *cells*) 1)
  (setf (gethash (cons 54 21) *cells*) 1)
  (setf (gethash (cons 56 22) *cells*) 1)
  (setf (gethash (cons 56 21) *cells*) 1)
  (setf (gethash (cons 56 20) *cells*) 1)
  (setf (gethash (cons 57 21) *cells*) 1))

(defun init-acorn ()
  (setf (gethash (cons 50 25) *cells*) 1)
  (setf (gethash (cons 51 23) *cells*) 1)
  (setf (gethash (cons 51 25) *cells*) 1)
  (setf (gethash (cons 53 24) *cells*) 1)
  (setf (gethash (cons 54 25) *cells*) 1)
  (setf (gethash (cons 55 25) *cells*) 1)
  (setf (gethash (cons 56 25) *cells*) 1))

(defun init-diehard ()
  (setf (gethash (cons 50 28) *cells*) 1)
  (setf (gethash (cons 51 28) *cells*) 1)
  (setf (gethash (cons 51 29) *cells*) 1)
  (setf (gethash (cons 55 29) *cells*) 1)
  (setf (gethash (cons 56 27) *cells*) 1)
  (setf (gethash (cons 56 29) *cells*) 1)
  (setf (gethash (cons 57 29) *cells*) 1))

(defun init-rpen ()
  (setf (gethash (cons 80 20) *cells*) 1)
  (setf (gethash (cons 81 19) *cells*) 1)
  (setf (gethash (cons 81 20) *cells*) 1)
  (setf (gethash (cons 81 21) *cells*) 1)
  (setf (gethash (cons 82 19) *cells*) 1))

(defun init-ggg ()
  (setf (gethash (cons 2 6) *cells*) 1)
  (setf (gethash (cons 3 6) *cells*) 1)
  (setf (gethash (cons 2 7) *cells*) 1)
  (setf (gethash (cons 3 7) *cells*) 1)
  (setf (gethash (cons 12 6) *cells*) 1)
  (setf (gethash (cons 12 7) *cells*) 1)
  (setf (gethash (cons 12 8) *cells*) 1)
  (setf (gethash (cons 13 5) *cells*) 1)
  (setf (gethash (cons 13 9) *cells*) 1)
  (setf (gethash (cons 14 4) *cells*) 1)
  (setf (gethash (cons 14 10) *cells*) 1)
  (setf (gethash (cons 15 4) *cells*) 1)
  (setf (gethash (cons 15 10) *cells*) 1)
  (setf (gethash (cons 16 7) *cells*) 1)
  (setf (gethash (cons 17 5) *cells*) 1)
  (setf (gethash (cons 17 9) *cells*) 1)
  (setf (gethash (cons 18 6) *cells*) 1)
  (setf (gethash (cons 18 7) *cells*) 1)
  (setf (gethash (cons 18 8) *cells*) 1)
  (setf (gethash (cons 19 7) *cells*) 1)
  (setf (gethash (cons 22 4) *cells*) 1)
  (setf (gethash (cons 22 5) *cells*) 1)
  (setf (gethash (cons 22 6) *cells*) 1)
  (setf (gethash (cons 23 4) *cells*) 1)
  (setf (gethash (cons 23 5) *cells*) 1)
  (setf (gethash (cons 23 6) *cells*) 1)
  (setf (gethash (cons 24 3) *cells*) 1)
  (setf (gethash (cons 24 7) *cells*) 1)
  (setf (gethash (cons 26 2) *cells*) 1)
  (setf (gethash (cons 26 3) *cells*) 1)
  (setf (gethash (cons 26 7) *cells*) 1)
  (setf (gethash (cons 26 8) *cells*) 1)
  (setf (gethash (cons 36 4) *cells*) 1)
  (setf (gethash (cons 36 5) *cells*) 1)
  (setf (gethash (cons 37 4) *cells*) 1)
  (setf (gethash (cons 37 5) *cells*) 1))
  
(defun copy-hash-table (table)
   (let ((new-table (make-hash-table :size (hash-table-size table) :test 'equal)))
      (maphash #'(lambda(key value)
                    (setf (gethash key new-table) value))
           table)
      new-table))

(defun rtprint (in)
  (format *standard-output* "~a" in)
  (force-output *standard-output*))

(defun random-cells (left top width height)
   (let ((pos (cons (+ left (random width)) (+ top (random height)))))
        (setf (gethash pos *cells*) 1)))

(defun next-gen ()
  (setf *cells-temp* (copy-hash-table *cells*))
  (do ((y 0 (1+ y)))
      ((>= y *height*))
    (do ((x 0 (1+ x)))
        ((>= x *width*))
      (let ((surcells (+ (or (gethash (cons x (mod (1+ y) *height*)) *cells*) 0) (or (gethash (cons (mod (1+ x) *width*) (mod (1+ y) *height*)) *cells*) 0)
                         (or (gethash (cons (mod (1+ x) *width*) y) *cells*) 0) (or (gethash (cons (mod (1+ x) *width*) (mod (1- y) *height*)) *cells*) 0)
                         (or (gethash (cons x (mod (1- y) *height*)) *cells*) 0) (or (gethash (cons (mod (1- x) *width*) (mod (1- y) *height*)) *cells*) 0)
                         (or (gethash (cons (mod (1- x) *width*) y) *cells*) 0) (or (gethash (cons (mod (1- x) *width*) (mod (1+ y) *height*)) *cells*) 0))))
       (cond ((= surcells 2) ())
             ((= surcells 3) (setf (gethash (cons x y) *cells-temp*) 1))
             ((or (< surcells 2) (> surcells 3)) (setf (gethash (cons x y) *cells-temp*) nil))))))
  (setf *cells* (copy-hash-table *cells-temp*)))

(defun draw-cli ()
  (do ((y 0 (1+ y)))
      ((>= y *height*))
    (format t "~%|")
    (do ((x 0 (1+ x)))
        ((>= x *width*))
      (cond ((gethash (cons x y) *cells*) (format t "*"))
            (t (format t " "))))
     (format t "|")))

(defun init-random (&optional (rep 1000))
  (do ((i 0 (1+ i)))
      ((>= i rep))
    (random-cells 0 0 *width* *height*)))  

;;Rewrite this... Get rid of evil "loop" macro...
(defun GOL-cli ()
  (draw-cli)
  (fresh-line)
  (let ((str (read-line)))
    (cond ((equal str "quit") ())
          ((equal str "auto") ;;Find way to stop this after signal
            (do ((i 0 (1+ i)))
                ((< i 0))
              (next-gen)
              (draw-cli)
              (sleep .1)))
          (t (let ((x (parse-integer str :junk-allowed t)))
               (if x
                   (loop for i
                      below x
                      do (next-gen)
                      if (zerop (mod i 100))
                      do (rtprint "."))
                   (next-gen))
               (GOL-cli))))))
               
(defun GOL (&optional (delay 0))
  (sdl:with-init ()
    (sdl:window (* *pixsize* *width*) (* *pixsize* *height*) :title-caption "Lisp Life")
    (setf (sdl:frame-rate) 60)
    (sdl:with-events ()
      (:quit-event () t)
      (:idle ()
        (sleep delay)
        (next-gen)
        (do ((y 0 (1+ y)))
            ((>= y *height*))
          (do ((x 0 (1+ x)))
              ((>= x *width*))
            (cond ((gethash (cons x y) *cells*)
                  (sdl-gfx:draw-box (sdl:rectangle :x (* x *pixsize*) :y (* y *pixsize*) :w *pixsize* :h *pixsize*)
                                       :color sdl:*white*))
                  (t (sdl-gfx:draw-box (sdl:rectangle :x (* x *pixsize*) :y (* y *pixsize*) :w *pixsize* :h *pixsize*)
                                       :color sdl:*black*)))))
        (sdl:update-display)))))
